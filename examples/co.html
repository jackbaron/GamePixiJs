<html>
        <meta charset="utf-8">
    <title>
        
        Cơ
    </title>
    <body>
        <script src="../pixi/pixi.min.js"></script>
        <script>
            //Aliases
            let Application = PIXI.Application,
                Container = PIXI.Container,
                loader = PIXI.loader,
                Text = PIXI.Text,
                TextStyle = PIXI.TextStyle,
                resources = PIXI.loader.resources,
                TextureCache = PIXI.utils.TextureCache,
                Sprite = PIXI.Sprite,
                Rectangle = PIXI.Rectangle;

                let app = new Application ({
                    width : 240,
                    height : 240,
                    antialiasing: true, //background
                    transparent: false, //border
                    resolution: 1
                });
                
                let playerTurn = cpuTurn = false;

                let imagePlayer = "player_on.png",
                    imageCpu    = "cpu_off.png",
                    cheesePlayer = "chess_player.png",
                    chessCpu    = "chess_cpu.png",
                    yellow      = "yellow.png",
                    turnPlayer  = "turn_player.png",
                    handImage   = "hand.png",
                    pointPlayerText = "2",
                    pointCpuText   = "2";
                
                let mode = "easy"; // default mode game easy and hard

                // set text point cpu player
                let style = new TextStyle ({
                    fontFamily: "Arial",
                    fontSize: 18,
                    fontWeight : "bold"
                });
                let pointPlayer = new Text(pointPlayerText, style);
                let pointCpu = new Text(pointCpuText, style);

                let chessPiecePlayer = [],
                    chessPieceCpu    = [],
                    yellowSuggest    = [],
                    listChessChange  = [],
                    animateHunman    = [];
                    suggestNextDisplay = [];

                document.body.appendChild(app.view);

                loader
                    .add("images/chess.json")
                    .load(setup);

                let change1, change2, change3, groupContainer,
                containerWidth,
                centerScreen,
                widthChess, heightChess,
                centerScreenWidth,
                centerScreenHeight,
                checkSuggestNextDisplay,
                backgroundStart, topImagePlayer, topImagePlayerOff, topImageCpu, topImageCpuOff, turnPlayerText, chessCpuDisplay, chessCpuDisplay1, yellowDisplay, chessPlayerDisplay, chessPlayerDisplay1, handDisplay;
                
                
                function setup() {
                    // set background
                    let background = new Sprite(resources["images/chess.json"].textures["startco.png"]),
                        mode1 = new Sprite(resources["images/chess.json"].textures["1.png"]), // easy
                        mode2 = new Sprite(resources["images/chess.json"].textures["2.png"]); // hard

                    // set change chess
                    change1 = new Sprite(resources["images/chess.json"].textures["change1.png"]);
                    change2 = new Sprite(resources["images/chess.json"].textures["change2.png"]);
                    change3 = new Sprite(resources["images/chess.json"].textures["change3.png"]);
                    // set click choose mode
                    mode1.interactive = mode2.interactive = true;
                    // Shows hand cursor
                    mode1.buttonMode = mode2.buttonMode = true;
                    
                    app.stage.addChild(background, mode1, mode2);

                    //create container group
                    groupContainer = new Container();
                    groupContainer.position.set(28, 33);
                    centerScreen = app.stage.width - mode1.width;
                    //set position
                    mode1.position.set(centerScreen/2, 155);
                    mode2.position.set(centerScreen/2, 183);
                    
                    // set display start game 
                    backgroundStart = new Sprite(resources["images/chess.json"].textures["bgco.png"]),
                        topImagePlayer = new Sprite(resources["images/chess.json"].textures[imagePlayer]),
                        topImagePlayerOff = new Sprite(resources["images/chess.json"].textures["player_off.png"]),
                        topImageCpu = new Sprite(resources["images/chess.json"].textures[imageCpu]),
                        topImageCpuOff = new Sprite(resources["images/chess.json"].textures["cpu_off.png"])
                        turnPlayerText = new Sprite(resources["images/chess.json"].textures[turnPlayer]);
                        chessCpuDisplay = new Sprite(resources["images/chess.json"].textures[chessCpu]); // color chess cpu
                        chessCpuDisplay1 = new Sprite(resources["images/chess.json"].textures[chessCpu]); // color chess cpu
                        yellowDisplay = new Sprite(resources["images/chess.json"].textures[yellow]); // Suggest the next country
                        chessPlayerDisplay = new Sprite(resources["images/chess.json"].textures[cheesePlayer]), // color chess player
                        chessPlayerDisplay1 = new Sprite(resources["images/chess.json"].textures[cheesePlayer])// color chess player
                        handDisplay = new Sprite(resources["images/chess.json"].textures[handImage]);
                        groupContainer.addChild(
                            chessCpuDisplay,
                            chessPlayerDisplay,
                            yellowDisplay,
                            chessCpuDisplay1,
                            chessPlayerDisplay1,
                            handDisplay
                        )
                    app.stage.addChild(backgroundStart, groupContainer, topImagePlayer, topImageCpu, turnPlayerText);
                    backgroundStart.visible = pointPlayer.visible = pointCpu.visible = topImagePlayer.visible = topImageCpu.visible = turnPlayerText.visible = chessCpuDisplay.visible = chessPlayerDisplay.visible = yellowDisplay.visible = chessCpuDisplay1.visible = chessPlayerDisplay1.visible = handDisplay.visible = false ;
                    
                    //set position top image player
                    topImagePlayer.position.set(10, 3);
                    topImageCpu.position.set(120, 3);
                    turnPlayerText.position.set(3, 227);
                    
                    //set width and height chess 
                    widthChess = chessCpuDisplay.width;
                    heightChess = chessCpuDisplay.height;
                    // hand = chess = 20, yellow = 21, app =240, container = 240 - container.x*2 = 184, mỗi ô vuông bằng = 184/8 = 23. yellow = 21 + (23-21)
                    // set width 
                    containerWidth = containerHeight = (yellowDisplay.width * 8 + 16);
                    centerScreenWidth = containerWidth / 2 - chessCpuDisplay.width - 3; // chess = 20 => chess = 20 +3
                    centerScreenHeight = containerHeight / 2 - chessCpuDisplay.width - 3;
                    // console.log(chessCpuDisplay.texture.textureCacheIds[0]); get name image
                    //set chess cpu and player
                    chessCpuDisplay.position.set(centerScreenWidth , centerScreenHeight);
                    chessCpuDisplay1.position.set(centerScreenWidth  + yellowDisplay.width + 2, centerScreenHeight + yellowDisplay.height + 2);
                    // push array list cpu
                    chessPieceCpu[chessCpuDisplay.x +"-" + chessCpuDisplay.y] = chessCpuDisplay;
                    chessPieceCpu[chessCpuDisplay1.x + "-" + chessCpuDisplay1.y] = chessCpuDisplay1;
                    // player
                    chessPlayerDisplay.position.set(chessCpuDisplay.x + yellowDisplay.width + 2, chessCpuDisplay.y);
                    chessPlayerDisplay1.position.set(chessCpuDisplay1.x - yellowDisplay.width - 2, chessCpuDisplay1.y);
                    // push array list player
                    chessPiecePlayer[chessPlayerDisplay1.x +"-" + chessCpuDisplay1.y] = chessPlayerDisplay1;
                    chessPiecePlayer[chessPlayerDisplay.x + "-" + chessCpuDisplay.y] = chessPlayerDisplay;
                    // set position hand 
                    handDisplay.position.set(centerScreenWidth - 3, centerScreenHeight + (chessCpuDisplay.height)/2 -3);
                    // add text set position point
                    pointPlayer.position.set(topImagePlayer.x + topImagePlayer.width + 10, 1);
                    pointCpu.position.set(topImageCpu.x + topImageCpu.width + 10, 1);
                    app.stage.addChild(pointPlayer, pointCpu);
                    //set hand move
                    handDisplay.vx = 0;
                    handDisplay.vy = 0;
                    

                    // set event click choose mode
                    mode1.on('pointerdown', function(e) {
                        mode = "easy";
                        backgroundStart.visible = topImagePlayer.visible = pointPlayer.visible = pointCpu.visible = topImageCpu.visible = turnPlayerText.visible = chessCpuDisplay.visible = chessPlayerDisplay.visible =  chessCpuDisplay1.visible = chessPlayerDisplay1.visible = handDisplay.visible = true;
                        playerTurn= true;
                        // remove screen intro game
                        background.destroy();
                        mode1.destroy();
                        mode2.destroy();
                        suggestNextDisplay = suggestNext(chessPiecePlayer);
                        //remove empty array
                        checkSuggestNextDisplay = suggestNextDisplay.filter(function (el) {
                            return el != null;
                        });
                        displaySuggest(suggestNextDisplay);
                    });

                    mode2.on('pointerdown', function(e) {
                        mode = "hard";
                        backgroundStart.visible = topImagePlayer.visible = pointPlayer.visible = pointCpu.visible = topImageCpu.visible = turnPlayerText.visible = chessCpuDisplay.visible = chessPlayerDisplay.visible = chessCpuDisplay1.visible = chessPlayerDisplay1.visible = handDisplay.visible = true;
                        playerTurn = true;
                        // remove screen intro game
                        background.destroy();
                        mode1.destroy();
                        mode2.destroy();
                        suggestNextDisplay = suggestNext(chessPiecePlayer);
                        //remove empty array
                        checkSuggestNextDisplay = suggestNextDisplay.filter(function (el) {
                            return el != null;
                        });
                        displaySuggest(suggestNextDisplay);
                    });  
                }

                // click suggest 
                // chessPieceX coordinates x
                // chessPieceY coordinates y
                // i direction
                function playChess(chessPieceX, chessPieceY, direction) {
                    let hunmanTextures = [], i;
                    if (playerTurn) {
                        for (i = 3; i >= 0; i--) {
                            var texture = PIXI.Texture.fromFrame('change' + i + '.png');
                            hunmanTextures.push(texture);
                        }

                        // create chess where coordinates click
                        chessPiecePlayer[chessPieceX + "-" + chessPieceY] = new Sprite(resources["images/chess.json"].textures[cheesePlayer]);
                        chessPiecePlayer[chessPieceX + "-" + chessPieceY].position.set(chessPieceX, chessPieceY);
                        groupContainer.addChild(chessPiecePlayer[chessPieceX + "-" + chessPieceY]);
                        
                        // remove all suggest
                        for (let elenmentSuggest in yellowSuggest) {
                            yellowSuggest[elenmentSuggest].destroy();
                        }
                        // remove sprite
                        listChessChange[direction].forEach( value => {
                            animateHunman[value] = new PIXI.extras.AnimatedSprite(hunmanTextures);
                            animateHunman[value].x = chessPieceCpu[value].x;
                            animateHunman[value].y = chessPieceCpu[value].y;
                            animateHunman[value].gotoAndPlay(0);
                            animateHunman[value].animationSpeed = 0.9;
                            animateHunman[value].loop = false;
                            groupContainer.addChild(animateHunman[value]);

                            //create chess player
                            chessPiecePlayer[value] = new Sprite(resources["images/chess.json"].textures[cheesePlayer]);
                            chessPiecePlayer[value].position.set(chessPieceCpu[value].x, chessPieceCpu[value].y);

                            chessPieceCpu[value].destroy();
                            delete chessPieceCpu[value];
                        })
                        // change point
                        pointPlayerText = parseInt(pointPlayerText) + listChessChange[direction].length + 1;
                        pointPlayer.setText(pointPlayerText);
                        pointCpuText = parseInt(pointCpuText) - listChessChange[direction].length;
                        pointCpu.setText(pointCpuText);
                        // turn off player turn on cpu
                        playerTurn = false;
                        cpuTurn = true;
                        yellowSuggest = []; 
                        handDisplay.position.set(chessPieceX- 3, chessPieceY + heightChess/2 -3);
                        groupContainer.addChild(handDisplay);
                        suggestNextDisplay = suggestNext(chessPieceCpu);
                        // topImagePlayer.texture = topImagePlayerOff;
                        // topImageCpu.texture = topImageCpuOff;
                        setTimeout(function(){
                            displaySuggest(suggestNextDisplay); 
                            // enable cpu top screen
                        }, hunmanTextures.length * 0.9);
                    } else {
                        // remove all suggest
                        for (let elenmentSuggest in yellowSuggest) {
                            yellowSuggest[elenmentSuggest].destroy();
                        }
                        for (i = 1; i <= 4; i++) {
                            var texture = PIXI.Texture.fromFrame('change' + i + '.png');
                            hunmanTextures.push(texture);
                        }
                        //cpu
                        // create chess where coordinates click
                        chessPieceCpu[chessPieceX + "-" + chessPieceY] = new Sprite(resources["images/chess.json"].textures[chessCpu]);
                        chessPieceCpu[chessPieceX + "-" + chessPieceY].position.set(chessPieceX, chessPieceY);
                        groupContainer.addChild(chessPieceCpu[chessPieceX + "-" + chessPieceY]);
                        // remove sprite
                        listChessChange[direction].forEach( value => {
                            animateHunman[value] = new PIXI.extras.AnimatedSprite(hunmanTextures);
                            // remove sprite
                            animateHunman[value].x = chessPiecePlayer[value].x;
                            animateHunman[value].y = chessPiecePlayer[value].y;
                            animateHunman[value].gotoAndPlay(0);
                            animateHunman[value].animationSpeed = 0.9;
                            animateHunman[value].loop = false;
                            groupContainer.addChild(animateHunman[value]);

                            //create chess cpu
                            chessPieceCpu[value] = new Sprite(resources["images/chess.json"].textures[chessCpu]);
                            chessPieceCpu[value].position.set(chessPiecePlayer[value].x, chessPiecePlayer[value].y);
                            //remove chess player;    
                            chessPiecePlayer[value].destroy();
                            delete chessPiecePlayer[value];
                        });
                        // change point
                        pointPlayerText = parseInt(pointPlayerText) - listChessChange[direction].length;
                        pointPlayer.setText(pointPlayerText);
                        pointCpuText = parseInt(pointCpuText) + listChessChange[direction].length + 1;
                        pointCpu.setText(pointCpuText);
                        // turn on player turn off cpu
                        playerTurn = true;
                        cpuTurn = true;
                        // remove all suggest
                        yellowSuggest = []; 
                        //suggesst CPU
                        suggestNextDisplay = suggestNext(chessPiecePlayer);
                        setTimeout(function(){
                            displaySuggest(suggestNextDisplay); 
                        }, hunmanTextures.length * 0.9);
                    }
                } 


                //     
                // display directions suggest
                function displaySuggest(coordinates) {
                    let myArray = []
                    for (let i in coordinates) {
                        yellowSuggest[i] = new Sprite(resources["images/chess.json"].textures[yellow]);
                        yellowSuggest[i].position.set(coordinates[i].x, coordinates[i].y);
                        // set click choose mode
                        yellowSuggest[i].interactive = true;
                        // Shows hand cursor
                        yellowSuggest[i].buttonMode = true;
                        yellowSuggest[i].on('pointerdown', function(e) {
                            playChess(coordinates[i].x, coordinates[i].y, i);
                        });
                        groupContainer.addChild(yellowSuggest[i]);
                        if (playerTurn) {
                            // display suggest
                        } else {
                            myArray.push(i);
                        }
                    }
                    if (!playerTurn) {
                        // cpu random pointerdown
                        // let rand = myArray[Math.floor(Math.random() * myArray.length)];
                        // playChess(yellowSuggest[rand].x, yellowSuggest[rand].y, rand);
                    }
                }

                // check suggestNext    
                function suggestNext(listChess) {
                    if (playerTurn) {
                        console.log("Player");
                        console.log(chessPiecePlayer);
                        console.log(chessPieceCpu);
                    } else {
                        console.log("CPU");
                        console.log(chessPieceCpu);
                        console.log(chessPiecePlayer);
                    }
                    listChessChange = []
                    let coordinatesSuggest = [];
                    for (let element in listChess) {
                        // console.log(listChess[element]);
                        // check left 
                        // check 8 directions for 1 chess piece
                        for ( let i = 0; i <= 7 ; i++) {
                            coordinatesSuggest = checkMove(listChess[element].x, listChess[element].y, i, coordinatesSuggest, listChess[element].x, listChess[element].y);
                        }
                    }
                    // return coordinates suggest
                    return coordinatesSuggest;
                }
                /**
                 * chessPieceX tọa độ x
                 * chessPieceY tọa độ y
                 * directions tọa độ từ 0 -> 7. Mỗi cờ sẽ đánh được 8 hướng
                 * spriteSuggest mảng gợi ý nước đánh
                 * coordinatesXRoot tọa độ x cờ bắt đầu check gợi ý
                 * coordinatesYRoot tọa độ y cờ bắt đầu check gợi ý
                 * nextX tọa độ tiếp theo sau khi check để kiểm tra xem cờ tiếp theo có phải là của người chơi hoặc cpu xét sự bao bọc cờ còn lại giữa 2 quân cờ
                 * nextY --..
                 */
                function checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot) {
                    let move = (yellowDisplay.width + 2);
                    let moveLeft, next, moveRight, moveTop, moveBottom, listArr, nextX, nextY;
                    let tmp = directions + "-" + coordinatesXRoot + "-" + coordinatesYRoot;
                    // check left
                    if (directions === 0) {
                        moveLeft = chessPieceX - move;
                        nextX = moveLeft - move;
                        // check limit on the left
                        if (moveLeft < move) {
                            return spriteSuggest; //limit left
                        }
                        // check exitst chesse piece cpu or chess piece player
                        if (playerTurn) {
                            // Kiểm tra xem quân tiếp theo có phải là của player không. Nếu phải thì cờ cpu đang được bao bọc trong player delete mảng and return
                            if (chessPiecePlayer.hasOwnProperty(nextX + "-" + chessPieceY)) {
                                delete listChessChange[tmp];
                                delete spriteSuggest[tmp];
                                return spriteSuggest; //chess next player;
                            }
                            if (chessPieceCpu.hasOwnProperty(moveLeft + "-" + chessPieceY) && (nextX >= move)) {
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveLeft + "-" + chessPieceY]);
                                } else {
                                    listChessChange[tmp] = [moveLeft + "-" + chessPieceY];
                                }
                                // exitst
                                chessPieceX = moveLeft;
                                spriteSuggest[tmp] = {"x" : nextX, "y" : chessPieceY};
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        } else {
                            // Kiểm tra xem quân tiếp theo có phải là của cpu không. Nếu phải thì cờ player đang được bao bọc trong cpu delete mảng and return
                            if (chessPieceCpu.hasOwnProperty(nextX + "-" + chessPieceY)) {
                                delete listChessChange[tmp];
                                delete spriteSuggest[tmp];
                                return spriteSuggest; //chess next player;
                            }
                            if (chessPiecePlayer.hasOwnProperty(moveLeft + "-" + chessPieceY) && (nextX >= move)) {
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveLeft + "-" + chessPieceY]);
                                } else {
                                    listChessChange[tmp] = [moveLeft + "-" + chessPieceY];
                                }
                                // exitst
                                chessPieceX = moveLeft;
                                spriteSuggest[tmp] = {"x" : nextX, "y" : chessPieceY};
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        }
                        
                    } else if (directions === 4) {
                        // check right
                        moveRight = chessPieceX + move;
                        nextX = moveRight + move;
                        // check limit on the right
                        if (moveRight >= containerWidth) {
                            return spriteSuggest; //limit right
                        }

                        if (playerTurn) {
                            // Kiểm tra xem quân tiếp theo có phải là của player không. Nếu phải thì cờ cpu đang được bao bọc trong player delete mảng and return
                            if (chessPiecePlayer.hasOwnProperty(nextX + "-" + chessPieceY)) {
                                delete listChessChange[tmp];
                                delete spriteSuggest[tmp];
                                return spriteSuggest; //chess next player;
                            }
                            if (chessPieceCpu.hasOwnProperty(moveRight + "-" + chessPieceY) && (nextX < containerWidth)) {
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveRight + "-" + chessPieceY]);
                                } else {
                                    listChessChange[tmp] = [moveRight + "-" + chessPieceY];
                                }
                                // exitst
                                chessPieceX = moveRight;
                                spriteSuggest[tmp] = {"x" : nextX, "y" : chessPieceY};
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        } else {
                            // Kiểm tra xem quân tiếp theo có phải là của cpu không. Nếu phải thì cờ player đang được bao bọc trong cpu delete mảng and return
                            if (chessPieceCpu.hasOwnProperty(nextX + "-" + chessPieceY)) {
                                delete listChessChange[tmp];
                                delete spriteSuggest[tmp];
                                return spriteSuggest; //chess next cpu;
                            }
                            if (chessPiecePlayer.hasOwnProperty(moveRight + "-" + chessPieceY) && (nextX < containerWidth)) {
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveRight + "-" + chessPieceY]);
                                } else {
                                    listChessChange[tmp] = [moveRight + "-" + chessPieceY];
                                }
                                // exitst
                                chessPieceX = moveRight;
                                spriteSuggest[tmp] = {"x" : nextX, "y" : chessPieceY};
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        }
                        
                    } else if (directions === 2) {
                        // check top
                        moveTop = chessPieceY - move;
                        nextY = moveTop - move;
                        // check limit on the top
                        if (moveTop < move) {
                            return spriteSuggest; //limit top
                        }
                        if (playerTurn) {
                            // Kiểm tra xem quân tiếp theo có phải là của player không. Nếu phải thì cờ cpu đang được bao bọc trong player delete mảng and return
                            if (chessPiecePlayer.hasOwnProperty(chessPieceX + "-" + nextY)) {
                                delete listChessChange[tmp];
                                delete spriteSuggest[tmp];
                                return spriteSuggest; //chess next cpu;
                            }
                            if (chessPieceCpu.hasOwnProperty(chessPieceX + "-" + moveTop) && (nextY >= move)) {
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([chessPieceX + "-" + moveTop]);
                                } else {
                                    listChessChange[tmp] = [chessPieceX + "-" + moveTop];
                                }
                                // exitst
                                chessPieceY = moveTop;
                                spriteSuggest[tmp] = {"x" : chessPieceX, "y" : nextY};
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        } else {
                            // Kiểm tra xem quân tiếp theo có phải là của cpu không. Nếu phải thì cờ player đang được bao bọc trong cpu delete mảng and return
                            if (chessPieceCpu.hasOwnProperty(chessPieceX + "-" + nextY)) {
                                delete listChessChange[tmp];
                                delete spriteSuggest[tmp];
                                return spriteSuggest; //chess next cpu;
                            }
                            if (chessPiecePlayer.hasOwnProperty(chessPieceX + "-" + moveTop) && (nextY >= move)) {
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([chessPieceX + "-" + moveTop]);
                                } else {
                                    listChessChange[tmp] = [chessPieceX + "-" + moveTop];
                                }
                                // exitst
                                chessPieceY = moveTop;
                                spriteSuggest[tmp] = {"x" : chessPieceX, "y" : nextY};
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }    
                        }
                        
                    } else if (directions === 6) {
                        // check bottom
                        moveBottom = chessPieceY + move;
                        nextY = moveBottom + move;
                        // check limit on the bottom
                        if (moveBottom >= containerHeight) {
                            return spriteSuggest; //limit bottom
                        }
                        if (playerTurn) {
                            // Kiểm tra xem quân tiếp theo có phải là của player không. Nếu phải thì cờ cpu đang được bao bọc trong player delete mảng and return
                            if (chessPiecePlayer.hasOwnProperty(chessPieceX + "-" + nextY)) {
                                delete listChessChange[tmp];
                                delete spriteSuggest[tmp];
                                return spriteSuggest; //chess next cpu;
                            }
                            if (chessPieceCpu.hasOwnProperty(chessPieceX + "-" + moveBottom) && (nextY < containerHeight)) {
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([chessPieceX + "-" + moveBottom]);
                                } else {
                                    listChessChange[tmp] = [chessPieceX + "-" + moveBottom];
                                }
                                // exitst
                                chessPieceY = moveBottom;
                                spriteSuggest[tmp] = {"x" : chessPieceX, "y" : nextY};
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        } else {
                            // Kiểm tra xem quân tiếp theo có phải là của cpu không. Nếu phải thì cờ player đang được bao bọc trong cpu delete mảng and return
                            if (chessPieceCpu.hasOwnProperty(chessPieceX + "-" + nextY)) {
                                delete listChessChange[tmp];
                                delete spriteSuggest[tmp];
                                return spriteSuggest; //chess next cpu;
                            }
                            if (chessPiecePlayer.hasOwnProperty(chessPieceX + "-" + moveBottom) && (nextY < containerHeight)) {
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([chessPieceX + "-" + moveBottom]);
                                } else {
                                    listChessChange[tmp] = [chessPieceX + "-" + moveBottom];
                                }
                                // exitst
                                chessPieceY = moveBottom;
                                spriteSuggest[tmp] = {"x" : chessPieceX, "y" : nextY};
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        }
                        
                    } else if (directions === 1) {
                        moveLeft = chessPieceX - move;
                        moveTop = chessPieceY - move;

                        nextX = moveLeft - move;
                        nextY = moveTop - move;
                        // check limit on the left
                        if (moveLeft < move || moveTop < move) {
                            return spriteSuggest; //limit left
                        }
                        // check exitst chesse piece cpu or chess piece player
                        if (playerTurn) {
                            // Kiểm tra xem quân tiếp theo có phải là của player không. Nếu phải thì cờ cpu đang được bao bọc trong player delete mảng and return
                            if (chessPiecePlayer.hasOwnProperty(nextX + "-" + nextY)) {
                                delete listChessChange[tmp];
                                delete spriteSuggest[tmp];
                                return spriteSuggest; //chess next cpu;
                            }
                            if (chessPieceCpu.hasOwnProperty(moveLeft + "-" + moveTop) && (nextX >= move) && (nextY >= move)) {
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveLeft + "-" + moveTop]);
                                } else {
                                    listChessChange[tmp] = [moveLeft + "-" + moveTop];
                                }
                                // exitst
                                chessPieceX = moveLeft;
                                chessPieceY = moveTop;
                                spriteSuggest[tmp] = {"x" : nextX, "y" : nextY};
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        } else {
                            // Kiểm tra xem quân tiếp theo có phải là của cpu không. Nếu phải thì cờ player đang được bao bọc trong cpu delete mảng and return
                            if (chessPieceCpu.hasOwnProperty(nextX + "-" + nextY)) {
                                delete listChessChange[tmp];
                                delete spriteSuggest[tmp];
                                return spriteSuggest; //chess next cpu;
                            }
                            if (chessPiecePlayer.hasOwnProperty(moveLeft + "-" + moveTop) && (nextX >= move) && (nextY >= move)) {
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveLeft + "-" + moveTop]);
                                } else {
                                    listChessChange[tmp] = [moveLeft + "-" + moveTop];
                                }
                                // exitst
                                chessPieceX = moveLeft;
                                chessPieceY = moveTop;
                                spriteSuggest[tmp] = {"x" : nextX, "y" : nextY};
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        }
                    } else if (directions === 3) {
                        moveRight = chessPieceX + move;
                        moveTop = chessPieceY - move;

                        nextX = moveRight + move;
                        nextY = moveTop - move;
                        // check limit on the right
                        if (moveRight >= containerWidth || moveTop < move) {
                            return spriteSuggest; //limit right
                        }
                        // check exitst chesse piece cpu or chess piece player
                        if (playerTurn) {
                            // Kiểm tra xem quân tiếp theo có phải là của player không. Nếu phải thì cờ cpu đang được bao bọc trong player delete mảng and return
                            if (chessPiecePlayer.hasOwnProperty(nextX + "-" + nextY)) {
                                delete listChessChange[tmp];
                                delete spriteSuggest[tmp];
                                return spriteSuggest; //chess next cpu;
                            }
                            if (chessPieceCpu.hasOwnProperty(moveRight + "-" + moveTop) && (nextX < containerWidth) && (nextY >= move)) {
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveRight + "-" + moveTop]);
                                } else {
                                    listChessChange[tmp] = [moveRight + "-" + moveTop];
                                }
                                // exitst
                                chessPieceX = moveRight;
                                chessPieceY = moveTop;
                                spriteSuggest[tmp] = {"x" : nextX, "y" : nextY};
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        } else {
                            // Kiểm tra xem quân tiếp theo có phải là của cpu không. Nếu phải thì cờ player đang được bao bọc trong cpu delete mảng and return
                            if (chessPieceCpu.hasOwnProperty(nextX + "-" + nextY)) {
                                delete listChessChange[tmp];
                                delete spriteSuggest[tmp];
                                return spriteSuggest; //chess next cpu;
                            }
                            if (chessPiecePlayer.hasOwnProperty(moveRight + "-" + moveTop) && (nextX < containerWidth) && (nextY >= move)) {
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveRight + "-" + moveTop]);
                                } else {
                                    listChessChange[tmp] = [moveRight + "-" + moveTop];
                                }
                                // exitst
                                chessPieceX = moveRight;
                                chessPieceY = moveTop;
                                spriteSuggest[tmp] = {"x" : nextX, "y" : nextY};
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        }
                    } else if (directions === 5) {
                        moveRight = chessPieceX + move;
                        moveBottom = chessPieceY + move;

                        nextX = moveRight + move;
                        nextY = moveBottom + move;
                        // check limit on the right
                        if (moveRight >= containerWidth || moveBottom >= containerHeight) {
                            return spriteSuggest; //limit right
                        }
                        // check exitst chesse piece cpu or chess piece player
                        if (playerTurn) {
                            // Kiểm tra xem quân tiếp theo có phải là của player không. Nếu phải thì cờ cpu đang được bao bọc trong player delete mảng and return
                            if (chessPiecePlayer.hasOwnProperty(nextX + "-" + nextY)) {
                                delete listChessChange[tmp];
                                delete spriteSuggest[tmp];
                                return spriteSuggest; //chess next player;
                            }

                            if (chessPieceCpu.hasOwnProperty(moveRight + "-" + moveBottom) && (nextX < containerWidth) && (nextY < containerHeight)) {
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveRight + "-" + moveBottom]);
                                } else {
                                    listChessChange[tmp] = [moveRight + "-" + moveBottom];
                                }
                                // exitst
                                chessPieceX = moveRight;
                                chessPieceY = moveBottom;
                                spriteSuggest[tmp] = {"x" : nextX, "y" : nextY};
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        } else {
                            // Kiểm tra xem quân tiếp theo có phải là của cpu không. Nếu phải thì cờ player đang được bao bọc trong cpu delete mảng and return
                            if (chessPieceCpu.hasOwnProperty(nextX + "-" + nextY)) {
                                delete listChessChange[tmp];
                                delete spriteSuggest[tmp];
                                return spriteSuggest; //chess next player;
                            }
                            if (chessPiecePlayer.hasOwnProperty(moveRight + "-" + moveBottom) && (nextX < containerWidth) && (nextY < containerHeight)) {
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveRight + "-" + moveBottom]);
                                } else {
                                    listChessChange[tmp] = [moveRight + "-" + moveBottom];
                                }
                                // exitst
                                chessPieceX = moveRight;
                                chessPieceY = moveBottom;
                                spriteSuggest[tmp] = {"x" : nextX, "y" : nextY};
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        }
                    } else {
                        // directions = 7
                        moveLeft = chessPieceX - move;
                        moveBottom = chessPieceY + move;

                        nextX = moveLeft - move;
                        nextY = moveBottom + move;
                        // check limit on the right
                        if (moveLeft < move || moveBottom >= containerHeight) {
                            return spriteSuggest; //limit right
                        }
                        // check exitst chesse piece cpu or chess piece player
                        if (playerTurn) {
                            // Kiểm tra xem quân tiếp theo có phải là của player không. Nếu phải thì cờ cpu đang được bao bọc trong player delete mảng and return
                            if (chessPiecePlayer.hasOwnProperty(nextX + "-" + nextY)) {
                                delete listChessChange[tmp];
                                delete spriteSuggest[tmp];
                                return spriteSuggest; //chess next player;
                            }
                            if (chessPieceCpu.hasOwnProperty(moveLeft + "-" + moveBottom) && (nextX >= move) && (nextY < containerHeight)) {
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveLeft + "-" + moveBottom]);
                                } else {
                                    listChessChange[tmp] = [moveLeft + "-" + moveBottom];
                                }
                                // exitst
                                chessPieceX = moveLeft;
                                chessPieceY = moveBottom;
                                spriteSuggest[tmp] = {"x" : nextX, "y" : nextY};
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        } else {
                            // Kiểm tra xem quân tiếp theo có phải là của cpu không. Nếu phải thì cờ player đang được bao bọc trong cpu delete mảng and return
                            if (chessPieceCpu.hasOwnProperty(nextX + "-" + nextY)) {
                                delete listChessChange[tmp];
                                delete spriteSuggest[tmp];
                                return spriteSuggest; //chess next cpu;
                            }
                            if (chessPiecePlayer.hasOwnProperty(moveLeft + "-" + moveBottom) && (nextX >= move) && (nextY < containerHeight)) {
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveLeft + "-" + moveBottom]);
                                } else {
                                    listChessChange[tmp] = [moveLeft + "-" + moveBottom];
                                }
                                // exitst
                                chessPieceX = moveLeft;
                                chessPieceY = moveBottom;
                                spriteSuggest[tmp] = {"x" : nextX, "y" : nextY};
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        }
                    }

                    return spriteSuggest;
                }
        </script>
    </body>
</html>