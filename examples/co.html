<html>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        
        Cơ
    </title>
    <body>
        <style>
            canvas {
                width: 100%;
            }
        </style>
        <script src="../pixi/pixi.min.js"></script>
        <script>
            //Aliases
            let Application = PIXI.Application,
                Container = PIXI.Container,
                loader = PIXI.loader,
                Text = PIXI.Text,
                TextStyle = PIXI.TextStyle,
                resources = PIXI.loader.resources,
                TextureCache = PIXI.utils.TextureCache,
                Sprite = PIXI.Sprite,
                Rectangle = PIXI.Rectangle;

                let app = new Application ({
                    width : 240,
                    height : 240,
                    antialiasing: true, //background
                    transparent: false, //border
                    resolution: 1
                });
                
                let playerTurn = cpuTurn = false;

                let imagePlayer = "player_on.png",
                    imageCpu    = "cpu_off.png",
                    cheesePlayer = "chess_player.png",
                    chessCpu    = "chess_cpu.png",
                    yellow      = "yellow.png",
                    turnPlayer  = "turn_player.png",
                    handImage   = "hand.png",
                    pointPlayerText = "2",
                    pointCpuText   = "2";
                
                let mode = "easy"; // default mode game easy and hard

                // set text point cpu player
                let style = new TextStyle ({
                    fontFamily: "Arial",
                    fontSize: 18,
                    fontWeight : "bold"
                });
                let pointPlayer = new Text(pointPlayerText, style);
                let pointCpu = new Text(pointCpuText, style);

                let chessPiecePlayer = [],
                    chessPieceCpu    = [],
                    yellowSuggest    = [],
                    listChessChange  = [],
                    animateHunman    = [];
                    suggestNextDisplay = [];

                document.body.appendChild(app.view);

                loader
                    .add([
                        "images/chess.json",
                        "images/co/mes_lose.png",
                        "images/co/lose.png",
                        "images/co/pass.png",
                        "images/co/win.png",
                        "images/co/restart.png"
                    ])
                    .load(setup);

                let change1, change2, change3, groupContainer,
                containerWidth,
                centerScreen,
                widthChess, heightChess,
                centerScreenWidth,
                centerScreenHeight,
                checkSuggestNextDisplay,
                backgroundStart, topImagePlayer, topImagePlayerOff, topImageCpu, topImageCpuOff, turnPlayerText, chessCpuDisplay, chessCpuDisplay1, yellowDisplay, chessPlayerDisplay, chessPlayerDisplay1, handDisplay;
                
                
                function setup() {
                    // set background
                    let background = new Sprite(resources["images/chess.json"].textures["startco.png"]),
                        mode1 = new Sprite(resources["images/chess.json"].textures["1.png"]), // easy
                        mode2 = new Sprite(resources["images/chess.json"].textures["2.png"]); // hard

                    // set change chess
                    change1 = new Sprite(resources["images/chess.json"].textures["change1.png"]);
                    change2 = new Sprite(resources["images/chess.json"].textures["change2.png"]);
                    change3 = new Sprite(resources["images/chess.json"].textures["change3.png"]);
                    // set click choose mode
                    mode1.interactive = mode2.interactive = true;
                    // Shows hand cursor
                    mode1.buttonMode = mode2.buttonMode = true;
                    
                    app.stage.addChild(background, mode1, mode2);

                    //create container group
                    groupContainer = new Container();
                    groupContainer.position.set(28, 33);
                    centerScreen = app.stage.width - mode1.width;
                    //set position
                    mode1.position.set(centerScreen/2, 155);
                    mode2.position.set(centerScreen/2, 183);
                    
                    // set display start game 
                    backgroundStart = new Sprite(resources["images/chess.json"].textures["bgco.png"]),
                        topImagePlayer = new Sprite(resources["images/chess.json"].textures[imagePlayer]),
                        topImagePlayerOff = new Sprite(resources["images/chess.json"].textures["player_off.png"]),
                        topImagePlayerOn = new Sprite(resources["images/chess.json"].textures["player_on.png"]),
                        topImageCpu = new Sprite(resources["images/chess.json"].textures[imageCpu]),
                        topImageCpuOn = new Sprite(resources["images/chess.json"].textures["cpu_on.png"]),
                        topImageCpuOff = new Sprite(resources["images/chess.json"].textures["cpu_off.png"]),
                        turnPlayerText = new Sprite(resources["images/chess.json"].textures[turnPlayer]);
                        chessCpuDisplay = new Sprite(resources["images/chess.json"].textures[chessCpu]); // color chess cpu
                        chessCpuDisplay1 = new Sprite(resources["images/chess.json"].textures[chessCpu]); // color chess cpu
                        yellowDisplay = new Sprite(resources["images/chess.json"].textures[yellow]); // Suggest the next country
                        chessPlayerDisplay = new Sprite(resources["images/chess.json"].textures[cheesePlayer]), // color chess player
                        chessPlayerDisplay1 = new Sprite(resources["images/chess.json"].textures[cheesePlayer]),// color chess player
                        handDisplay = new Sprite(resources["images/chess.json"].textures[handImage]),
                        passImage = new Sprite(resources["images/co/pass.png"].texture);
                        groupContainer.addChild(
                            chessCpuDisplay,
                            chessPlayerDisplay,
                            yellowDisplay,
                            chessCpuDisplay1,
                            chessPlayerDisplay1,
                            handDisplay,
                            passImage,
                        )
                        
                    app.stage.addChild(backgroundStart, groupContainer, topImagePlayer, topImageCpu, turnPlayerText);
                    backgroundStart.visible = pointPlayer.visible = pointCpu.visible = topImagePlayer.visible = topImageCpu.visible = turnPlayerText.visible = chessCpuDisplay.visible = chessPlayerDisplay.visible = yellowDisplay.visible = chessCpuDisplay1.visible = chessPlayerDisplay1.visible = handDisplay.visible = false ;
                    
                    //set position top image player
                    topImagePlayer.position.set(10, 3);
                    topImageCpu.position.set(120, 3);
                    turnPlayerText.position.set(3, 227);
                    
                    
                    //set width and height chess 
                    widthChess = chessCpuDisplay.width;
                    heightChess = chessCpuDisplay.height;
                    // hand = chess = 20, yellow = 21, app =240, container = 240 - container.x*2 = 184, mỗi ô vuông bằng = 184/8 = 23. yellow = 21 + (23-21)
                    // set width 
                    containerWidth = containerHeight = (yellowDisplay.width * 8 + 16);
                    centerScreenWidth = containerWidth / 2 - chessCpuDisplay.width - 3; // chess = 20 => chess = 20 +3
                    centerScreenHeight = containerHeight / 2 - chessCpuDisplay.width - 3;

                    // console.log(chessCpuDisplay.texture.textureCacheIds[0]); get name image
                    passImage.position.set((containerWidth - passImage.width) / 2, centerScreenHeight);
                    passImage.zOrder = 10;
                    passImage.visible = false;
                    //set chess cpu and player
                    chessCpuDisplay.position.set(centerScreenWidth , centerScreenHeight);
                    chessCpuDisplay1.position.set(centerScreenWidth  + yellowDisplay.width + 2, centerScreenHeight + yellowDisplay.height + 2);
                    // push array list cpu
                    chessPieceCpu[chessCpuDisplay.x +"-" + chessCpuDisplay.y] = chessCpuDisplay;
                    chessPieceCpu[chessCpuDisplay1.x + "-" + chessCpuDisplay1.y] = chessCpuDisplay1;
                    // player
                    chessPlayerDisplay.position.set(chessCpuDisplay.x + yellowDisplay.width + 2, chessCpuDisplay.y);
                    chessPlayerDisplay1.position.set(chessCpuDisplay1.x - yellowDisplay.width - 2, chessCpuDisplay1.y);
                    // push array list player
                    chessPiecePlayer[chessPlayerDisplay1.x +"-" + chessCpuDisplay1.y] = chessPlayerDisplay1;
                    chessPiecePlayer[chessPlayerDisplay.x + "-" + chessCpuDisplay.y] = chessPlayerDisplay;
                    // set position hand 
                    handDisplay.position.set(centerScreenWidth - 3, centerScreenHeight + (chessCpuDisplay.height)/2 -3);
                    // add text set position point
                    pointPlayer.position.set(topImagePlayer.x + topImagePlayer.width + 10, 1);
                    pointCpu.position.set(topImageCpu.x + topImageCpu.width + 10, 1);
                    app.stage.addChild(pointPlayer, pointCpu);
                    //set hand move
                    handDisplay.vx = 0;
                    handDisplay.vy = 0;
                    

                    // set event click choose mode
                    mode1.on('pointerdown', function(e) {
                        mode = "easy";
                        backgroundStart.visible = topImagePlayer.visible = pointPlayer.visible = pointCpu.visible = topImageCpu.visible = turnPlayerText.visible = chessCpuDisplay.visible = chessPlayerDisplay.visible =  chessCpuDisplay1.visible = chessPlayerDisplay1.visible = handDisplay.visible = true;
                        playerTurn= true;
                        // remove screen intro game
                        background.destroy();
                        mode1.destroy();
                        mode2.destroy();
                        suggestNextDisplay = suggestNext(chessPiecePlayer);
                        //remove empty array
                        checkSuggestNextDisplay = suggestNextDisplay.filter(function (el) {
                            return el != null;
                        });
                        displaySuggest(suggestNextDisplay);
                    });

                    mode2.on('pointerdown', function(e) {
                        mode = "hard";
                        backgroundStart.visible = topImagePlayer.visible = pointPlayer.visible = pointCpu.visible = topImageCpu.visible = turnPlayerText.visible = chessCpuDisplay.visible = chessPlayerDisplay.visible = chessCpuDisplay1.visible = chessPlayerDisplay1.visible = handDisplay.visible = true;
                        playerTurn = true;
                        // remove screen intro game
                        background.destroy();
                        mode1.destroy();
                        mode2.destroy();
                        suggestNextDisplay = suggestNext(chessPiecePlayer);
                        //remove empty array
                        checkSuggestNextDisplay = suggestNextDisplay.filter(function (el) {
                            return el != null;
                        });
                        displaySuggest(suggestNextDisplay);
                    });  
                }
                // click suggest 
                // chessPieceX coordinates x
                // chessPieceY coordinates y
                // i direction
                function playChess(chessPieceX, chessPieceY, direction) {
                    let hunmanTextures = [], i;
                    if (playerTurn) {
                        for (i = 3; i >= 0; i--) {
                            var texture = PIXI.Texture.fromFrame('change' + i + '.png');
                            hunmanTextures.push(texture);
                        }

                        // create chess where coordinates click
                        chessPiecePlayer[chessPieceX + "-" + chessPieceY] = new Sprite(resources["images/chess.json"].textures[cheesePlayer]);
                        chessPiecePlayer[chessPieceX + "-" + chessPieceY].position.set(chessPieceX, chessPieceY);
                        groupContainer.addChild(chessPiecePlayer[chessPieceX + "-" + chessPieceY]);
                        
                        // remove all suggest
                        for (let elenmentSuggest in yellowSuggest) {
                            yellowSuggest[elenmentSuggest].destroy();
                        }
                        // remove sprite
                        listChessChange[direction].forEach( value => {
                            //create chess player
                            chessPiecePlayer[value] = new Sprite(resources["images/chess.json"].textures[cheesePlayer]);
                            chessPiecePlayer[value].position.set(chessPieceCpu[value].x, chessPieceCpu[value].y);
                            
                            chessPieceCpu[value].destroy();
                            delete chessPieceCpu[value];

                            animateHunman[value] = new PIXI.extras.AnimatedSprite(hunmanTextures);
                            animateHunman[value].x = chessPiecePlayer[value].x;
                            animateHunman[value].y = chessPiecePlayer[value].y;
                            animateHunman[value].gotoAndPlay(0);
                            animateHunman[value].animationSpeed = 0.09;
                            animateHunman[value].loop = false;
                            animateHunman[value].onComplete = function() {
                                animateHunman[value].destroy();
                                groupContainer.addChild(chessPiecePlayer[value], handDisplay);
                            }
                            groupContainer.addChild(animateHunman[value]);
                            
                        });
                        // change point
                        pointPlayerText = parseInt(pointPlayerText) + listChessChange[direction].length + 1;
                        pointPlayer.setText(pointPlayerText);
                        pointCpuText = parseInt(pointCpuText) - listChessChange[direction].length;
                        pointCpu.setText(pointCpuText);
                        // turn off player turn on cpu
                        playerTurn = false;
                        cpuTurn = true;
                        yellowSuggest = []; 
                        handDisplay.position.set(chessPieceX- 3, chessPieceY + heightChess/2 -3);
                        groupContainer.addChild(handDisplay);
                        suggestNextDisplay = suggestNext(chessPieceCpu);
                        // check cpu isset next suggest
                        if (Object.keys(suggestNextDisplay).length > 0) {
                            setTimeout(function(){
                                topImagePlayer.setTexture(PIXI.TextureCache['player_off.png']);
                                topImageCpu.setTexture(PIXI.TextureCache['cpu_on.png']);
                                displaySuggest(suggestNextDisplay); 
                            }, 2200);
                        } else {
                            playerTurn = true;
                            cpuTurn = false;
                            passImage.visible = true;
                            groupContainer.addChild(passImage);
                            suggestNextDisplay = suggestNext(chessPiecePlayer);
                            if (Object.keys(suggestNextDisplay).length > 0) {
                                groupContainer.on('sort', function(sprite) { sprite.zOrder = -sprite.y });
                                setTimeout(function(){
                                    passImage.visible = false;
                                    topImagePlayer.setTexture(PIXI.TextureCache['player_on.png']);
                                    topImageCpu.setTexture(PIXI.TextureCache['cpu_off.png']);
                                    displaySuggest(suggestNextDisplay); 
                                }, 2200);
                            } else {
                                setTimeout(function(){
                                    passImage.visible = false;
                                    finishGame();
                                }, 1000);
                            }
                        }
                        
                        
                    } else {
                        // remove all suggest
                        for (let elenmentSuggest in yellowSuggest) {
                            yellowSuggest[elenmentSuggest].destroy();
                        }
                        for (i = 1; i <= 4; i++) {
                            var texture = PIXI.Texture.fromFrame('change' + i + '.png');
                            hunmanTextures.push(texture);
                        }
                        //cpu
                        // create chess where coordinates click
                        chessPieceCpu[chessPieceX + "-" + chessPieceY] = new Sprite(resources["images/chess.json"].textures[chessCpu]);
                        chessPieceCpu[chessPieceX + "-" + chessPieceY].position.set(chessPieceX, chessPieceY);
                        groupContainer.addChild(chessPieceCpu[chessPieceX + "-" + chessPieceY]);
                        // remove sprite
                        listChessChange[direction].forEach( value => {
                            //create chess cpu
                            chessPieceCpu[value] = new Sprite(resources["images/chess.json"].textures[chessCpu]);
                            chessPieceCpu[value].position.set(chessPiecePlayer[value].x, chessPiecePlayer[value].y);
                            chessPieceCpu[value].zOrder = 1;
                            //remove chess player;    
                            chessPiecePlayer[value].destroy();
                            delete chessPiecePlayer[value];

                            animateHunman[value] = new PIXI.extras.AnimatedSprite(hunmanTextures);
                            // remove sprite
                            animateHunman[value].x = chessPieceCpu[value].x;
                            animateHunman[value].y = chessPieceCpu[value].y;
                            animateHunman[value].gotoAndPlay(0);
                            animateHunman[value].animationSpeed = 0.09;
                            animateHunman[value].loop = false;
                            animateHunman[value].onComplete = function() {
                                animateHunman[value].destroy();
                                groupContainer.addChild(chessPieceCpu[value], handDisplay);
                            }
                            groupContainer.addChild(animateHunman[value]);
                        });
                        // change point
                        pointPlayerText = parseInt(pointPlayerText) - listChessChange[direction].length;
                        pointPlayer.setText(pointPlayerText);
                        pointCpuText = parseInt(pointCpuText) + listChessChange[direction].length + 1;
                        pointCpu.setText(pointCpuText);
                        
                        // remove all suggest
                        yellowSuggest = []; 
                        handDisplay.position.set(chessPieceX- 3, chessPieceY + heightChess/2 -3);
                        groupContainer.addChild(handDisplay);
                        //suggesst CPU
                        playerTurn = true;
                        cpuTurn = false;
                        suggestNextDisplay = suggestNext(chessPiecePlayer);
                        if (Object.keys(suggestNextDisplay).length > 0) {
                            // turn on player turn off cpu
                            setTimeout(function(){
                                topImagePlayer.setTexture(PIXI.TextureCache['player_on.png']);
                                topImageCpu.setTexture(PIXI.TextureCache['cpu_off.png']);
                                displaySuggest(suggestNextDisplay); 
                            }, 2200);
                        } else {
                            playerTurn = false;
                            cpuTurn = true;
                            passImage.visible = true;
                            groupContainer.addChild(passImage);
                            suggestNextDisplay = suggestNext(chessPieceCpu);
                            if (Object.keys(suggestNextDisplay).length > 0) {
                                setTimeout(function(){
                                    passImage.visible = false;
                                    topImagePlayer.setTexture(PIXI.TextureCache['player_off.png']);
                                    topImageCpu.setTexture(PIXI.TextureCache['cpu_on.png']);
                                    displaySuggest(suggestNextDisplay); 
                                }, 2200);
                            } else {
                                //end game
                                //spirte end game
                                setTimeout(function(){
                                    passImage.visible = false;
                                    finishGame();
                                }, 1000);
                                
                            }
                            
                        }
                        
                    }
                } 

                function finishGame() {
                    let restartFlag = false;
                    restartImage = new Sprite(resources["images/co/restart.png"].texture);
                    restartImage.position.set((containerWidth - restartImage.width) /2, (containerHeight - restartImage.height)/ 2);
                    messLose = new Sprite(resources["images/co/mes_lose.png"].texture);
                    messLose.position.set((containerWidth - messLose.width) / 2, 5);
                    //spirte end game
                    if (pointPlayerText > pointCpuText) {
                        
                        //player win
                        winImage = new Sprite(resources["images/co/win.png"].texture);
                        winImage.position.set((containerWidth - winImage.width) / 2, centerScreenHeight);
                        groupContainer.addChild(
                            winImage,
                            messLose
                        );

                        setTimeout(() => {
                            winImage.destroy();
                            messLose.destroy();
                            restartFlag = true;
                            groupContainer.addChild(restartImage);
                        }, 1300);
                    } else {
                        // cpu win
                        loseImage = new Sprite(resources["images/co/lose.png"].texture);
                        // set position end game
                        loseImage.position.set((containerWidth - loseImage.width) / 2, centerScreenHeight);
                        groupContainer.addChild(
                            messLose,
                            loseImage
                        );
                        setTimeout(() => {
                            loseImage.destroy();
                            messLose.destroy();
                            restartFlag = true;
                            groupContainer.addChild(restartImage);
                        }, 1300);

                    }
                    let buttonContinue = new PIXI.Sprite(PIXI.Texture.BLACK);
                    buttonContinue.blendMode  = PIXI.BLEND_MODES.ADD; //Change with the color wanted
                    buttonContinue.width = restartImage.width/2;
                    buttonContinue.height = restartImage.height /2 - 80;
                    buttonContinue.x = restartImage.x + 19;
                    buttonContinue.y = restartImage.y + buttonContinue.height + 10;
                    buttonContinue.interactive  = true;
                    buttonContinue.buttonMode = true;
                    groupContainer.addChild(buttonContinue);
                    buttonContinue.on('pointerdown', function(e) {
                        for (let i in chessPieceCpu) {
                            chessPieceCpu[i].destroy();
                        }
                        for (let i in chessPiecePlayer) {
                            chessPiecePlayer[i].destroy();
                        }
                        chessPieceCpu = [];
                        chessPiecePlayer = [];
                        pointPlayerText = pointCpuText = 2;
                        pointPlayer.setText(pointPlayerText);
                        pointCpu.setText(pointCpuText);
                        //set chess cpu and player
                        chessCpuDisplay = new Sprite(resources["images/chess.json"].textures[chessCpu]); // color chess cpu
                        chessCpuDisplay1 = new Sprite(resources["images/chess.json"].textures[chessCpu]); // color chess cpu
                        chessCpuDisplay.position.set(centerScreenWidth , centerScreenHeight);
                        chessCpuDisplay1.position.set(centerScreenWidth  + yellowDisplay.width + 2, centerScreenHeight + yellowDisplay.height + 2);
                        // push array list cpu
                        chessPieceCpu[chessCpuDisplay.x +"-" + chessCpuDisplay.y] = chessCpuDisplay;
                        chessPieceCpu[chessCpuDisplay1.x + "-" + chessCpuDisplay1.y] = chessCpuDisplay1;
                        // player
                        chessPlayerDisplay = new Sprite(resources["images/chess.json"].textures[cheesePlayer]), // color chess player
                        chessPlayerDisplay1 = new Sprite(resources["images/chess.json"].textures[cheesePlayer]),// color chess player
                        chessPlayerDisplay.position.set(chessCpuDisplay.x + yellowDisplay.width + 2, chessCpuDisplay.y);
                        chessPlayerDisplay1.position.set(chessCpuDisplay1.x - yellowDisplay.width - 2, chessCpuDisplay1.y);
                        // push array list player
                        chessPiecePlayer[chessPlayerDisplay1.x +"-" + chessCpuDisplay1.y] = chessPlayerDisplay1;
                        chessPiecePlayer[chessPlayerDisplay.x + "-" + chessCpuDisplay.y] = chessPlayerDisplay;
                        handDisplay.position.set(centerScreenWidth - 3, centerScreenHeight + (chessCpuDisplay.height)/2 -3);
                        groupContainer.addChild(chessCpuDisplay, chessCpuDisplay1, chessPlayerDisplay, chessPlayerDisplay1, handDisplay);
                        buttonContinue.destroy();
                        restartImage.destroy();
                        playerTurn = true;
                        cpuTurn = false;
                        for (let elenmentSuggest in yellowSuggest) {
                            yellowSuggest[elenmentSuggest].destroy();
                        }
                        suggestNextDisplay = suggestNext(chessPiecePlayer);
                        //remove empty array
                        checkSuggestNextDisplay = suggestNextDisplay.filter(function (el) {
                            return el != null;
                        });
                        displaySuggest(suggestNextDisplay);
                    });
                }
                //     
                // display directions suggest
                function displaySuggest(coordinates) {
                    let myArray = [];
                    let arrTmp = [];
                    for (let i in coordinates) {
                        coordinates[i].forEach(function(element, key) {
                            if (key === coordinates[i].length - 1) {
                                // check and meger list chess change
                                let coordinateTmp = element.x + "-" + element.y;
                                if (arrTmp[coordinateTmp] === undefined) {
                                    arrTmp[coordinateTmp] = i;
                                } else {
                                    let mergeArr = listChessChange[arrTmp[coordinateTmp]].concat(listChessChange[i]);
                                    listChessChange[arrTmp[coordinateTmp]] = mergeArr;
                                    listChessChange[i] = mergeArr;
                                }
                            }
                            yellowSuggest[i] = new Sprite(resources["images/chess.json"].textures[yellow]);
                            yellowSuggest[i].position.set(element.x, element.y);
                            yellowSuggest[i].zOrder = 1;
                            // set click choose mode
                            yellowSuggest[i].interactive = true;
                            // Shows hand cursor
                            yellowSuggest[i].buttonMode = true;
                            yellowSuggest[i].on('pointerdown', function(e) {
                                playChess(element.x, element.y, i);
                            });
                            // check display suggest next
                            if (playerTurn) {

                                groupContainer.addChild(yellowSuggest[i], handDisplay);
                                // display suggest
                            } else {
                                myArray.push(i);
                            }
                        });
                        
                    }
                    
                    if (!playerTurn) {
                        // cpu random pointerdown\
                        if (mode === "easy") {
                            let rand = myArray[Math.floor(Math.random() * myArray.length)];
                            playChess(yellowSuggest[rand].x, yellowSuggest[rand].y, rand);
                        } else {
                            let maxlength = 0;
                            let key;
                            for (let i in listChessChange) {
                                if (listChessChange[i].length > maxlength) {
                                    maxlength = listChessChange[i].length;
                                    key = i;
                                }
                            }
                            if (maxlength === 1) {
                                let rand = myArray[Math.floor(Math.random() * myArray.length)];
                                playChess(yellowSuggest[rand].x, yellowSuggest[rand].y, rand);
                            }  else {
                                playChess(yellowSuggest[key].x, yellowSuggest[key].y, key);
                            }
                        }
                    }
                }
                

                // check suggestNext    
                function suggestNext(listChess) {
                    if (playerTurn) {
                        console.log("Player");
                        console.log(chessPiecePlayer);
                        console.log(chessPieceCpu);
                    } else {
                        console.log("CPU");
                        console.log(chessPieceCpu);
                        console.log(chessPiecePlayer);
                    }
                    listChessChange = []
                    let coordinatesSuggest = [];
                    for (let element in listChess) {
                        // console.log(listChess[element]);
                        // check left 
                        // check 8 directions for 1 chess piece
                        for ( let i = 0; i <= 7 ; i++) {
                            coordinatesSuggest = checkMove(listChess[element].x, listChess[element].y, i, coordinatesSuggest, listChess[element].x, listChess[element].y);
                        }
                    }
                    // return coordinates suggest
                    return coordinatesSuggest;
                }
                /**
                 * chessPieceX tọa độ x
                 * chessPieceY tọa độ y
                 * directions tọa độ từ 0 -> 7. Mỗi cờ sẽ đánh được 8 hướng
                 * spriteSuggest mảng gợi ý nước đánh
                 * coordinatesXRoot tọa độ x cờ bắt đầu check gợi ý
                 * coordinatesYRoot tọa độ y cờ bắt đầu check gợi ý
                 * nextX tọa độ tiếp theo sau khi check để kiểm tra xem cờ tiếp theo có phải là của người chơi hoặc cpu xét sự bao bọc cờ còn lại giữa 2 quân cờ
                 * nextY --..
                 */
                function checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot) {
                    let move = (yellowDisplay.width + 2);
                    let moveLeft, next, moveRight, moveTop, moveBottom, listArr, nextX, nextY;
                    let tmp = directions + "-" + coordinatesXRoot + "-" + coordinatesYRoot;
                    // check left
                    if (directions === 0) {
                        moveLeft = chessPieceX - move;
                        nextX = moveLeft - move;
                        // check limit on the left
                        if (moveLeft < move && !(chessPieceCpu.hasOwnProperty(moveLeft + "-" + chessPieceY) || chessPiecePlayer.hasOwnProperty(moveLeft + "-" + chessPieceY))) {
                            return spriteSuggest; //limit left
                        }
                        if (nextX < 0) {
                            delete listChessChange[tmp];
                            delete spriteSuggest[tmp];
                            return spriteSuggest; //chess next player;
                        }
                        // check exitst chesse piece cpu or chess piece player
                        if (playerTurn) {
                            if (chessPieceCpu.hasOwnProperty(moveLeft + "-" + chessPieceY)) {
                                // Kiểm tra xem quân tiếp theo có phải là của player không. Nếu phải thì cờ cpu đang được bao bọc trong player delete mảng and return
                                if (chessPiecePlayer.hasOwnProperty(nextX + "-" + chessPieceY)) {
                                    delete listChessChange[tmp];
                                    delete spriteSuggest[tmp];
                                    return spriteSuggest; //chess next player;
                                }
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveLeft + "-" + chessPieceY]);
                                } else {
                                    listChessChange[tmp] = [moveLeft + "-" + chessPieceY];
                                }
                                // exitst
                                chessPieceX = moveLeft;
                                spriteSuggest[tmp] = ([{"x" : nextX, "y" : chessPieceY}]);
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        } else {
                            
                            if (chessPiecePlayer.hasOwnProperty(moveLeft + "-" + chessPieceY)) {
                                // Kiểm tra xem quân tiếp theo có phải là của cpu không. Nếu phải thì cờ player đang được bao bọc trong cpu delete mảng and return
                                if (chessPieceCpu.hasOwnProperty(nextX + "-" + chessPieceY)) {
                                    delete listChessChange[tmp];
                                    delete spriteSuggest[tmp];
                                    return spriteSuggest; //chess next player;
                                }
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveLeft + "-" + chessPieceY]);
                                } else {
                                    listChessChange[tmp] = [moveLeft + "-" + chessPieceY];
                                }
                                // exitst
                                chessPieceX = moveLeft;
                                listArr = spriteSuggest[tmp];
                                spriteSuggest[tmp] = ([{"x" : nextX, "y" : chessPieceY}]);
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        }
                        
                    } else if (directions === 4) {
                        // check right
                        moveRight = chessPieceX + move;
                        nextX = moveRight + move;
                        // check limit on the right
                        
                        if (moveRight > containerWidth && !(chessPieceCpu.hasOwnProperty(moveRight + "-" + chessPieceY) || chessPiecePlayer.hasOwnProperty(moveRight + "-" + chessPieceY))) {
                            return spriteSuggest; //limit right
                        }
                        if (nextX > containerWidth) {
                            delete listChessChange[tmp];
                            delete spriteSuggest[tmp];
                            return spriteSuggest; //chess next player;
                        }
                        if (playerTurn) {
                            
                            if (chessPieceCpu.hasOwnProperty(moveRight + "-" + chessPieceY)) {
                                // Kiểm tra xem quân tiếp theo có phải là của player không. Nếu phải thì cờ cpu đang được bao bọc trong player delete mảng and return
                                if (chessPiecePlayer.hasOwnProperty(nextX + "-" + chessPieceY)) {
                                    delete listChessChange[tmp];
                                    delete spriteSuggest[tmp];
                                    return spriteSuggest; //chess next player;
                                }
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveRight + "-" + chessPieceY]);
                                } else {
                                    listChessChange[tmp] = [moveRight + "-" + chessPieceY];
                                }
                                // exitst
                                chessPieceX = moveRight;
                                spriteSuggest[tmp] = ([{"x" : nextX, "y" : chessPieceY}]);
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        } else {
                            
                            if (chessPiecePlayer.hasOwnProperty(moveRight + "-" + chessPieceY)) {
                                // Kiểm tra xem quân tiếp theo có phải là của cpu không. Nếu phải thì cờ player đang được bao bọc trong cpu delete mảng and return
                                if (chessPieceCpu.hasOwnProperty(nextX + "-" + chessPieceY)) {
                                    delete listChessChange[tmp];
                                    delete spriteSuggest[tmp];
                                    return spriteSuggest; //chess next cpu;
                                }
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveRight + "-" + chessPieceY]);
                                } else {
                                    listChessChange[tmp] = [moveRight + "-" + chessPieceY];
                                }
                                // exitst
                                chessPieceX = moveRight;
                                spriteSuggest[tmp] = ([{"x" : nextX, "y" : chessPieceY}]);
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        }
                        
                    } else if (directions === 2) {
                        // check top
                        moveTop = chessPieceY - move;
                        nextY = moveTop - move;
                        // check limit on the top
                        if (moveTop < move && !(chessPieceCpu.hasOwnProperty(chessPieceX + "-" + moveTop) || chessPiecePlayer.hasOwnProperty(chessPieceX + "-" + moveTop))) {
                            return spriteSuggest; //limit top
                        }
                        if (nextY < 0) {
                            delete listChessChange[tmp];
                            delete spriteSuggest[tmp];
                            return spriteSuggest; //chess next player;
                        }
                        if (playerTurn) {
                            
                            if (chessPieceCpu.hasOwnProperty(chessPieceX + "-" + moveTop)) {
                                // Kiểm tra xem quân tiếp theo có phải là của player không. Nếu phải thì cờ cpu đang được bao bọc trong player delete mảng and return
                                if (chessPiecePlayer.hasOwnProperty(chessPieceX + "-" + nextY)) {
                                    delete listChessChange[tmp];
                                    delete spriteSuggest[tmp];
                                    return spriteSuggest; //chess next cpu;
                                }
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([chessPieceX + "-" + moveTop]);
                                } else {
                                    listChessChange[tmp] = [chessPieceX + "-" + moveTop];
                                }
                                // exitst
                                chessPieceY = moveTop;
                                spriteSuggest[tmp] = ([{"x" : chessPieceX, "y" : nextY}]);
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        } else {
                            // Kiểm tra xem quân tiếp theo có phải là của cpu không. Nếu phải thì cờ player đang được bao bọc trong cpu delete mảng and return
                            if (chessPieceCpu.hasOwnProperty(chessPieceX + "-" + nextY)) {
                                delete listChessChange[tmp];
                                delete spriteSuggest[tmp];
                                return spriteSuggest; //chess next cpu;
                            }
                            if (chessPiecePlayer.hasOwnProperty(chessPieceX + "-" + moveTop)) {
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([chessPieceX + "-" + moveTop]);
                                } else {
                                    listChessChange[tmp] = [chessPieceX + "-" + moveTop];
                                }
                                // exitst
                                chessPieceY = moveTop;
                                spriteSuggest[tmp] = ([{"x" : chessPieceX, "y" : nextY}]);
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }    
                        }
                        
                    } else if (directions === 6) {
                        // check bottom
                        moveBottom = chessPieceY + move;
                        nextY = moveBottom + move;
                        // check limit on the bottom
                        if (moveBottom > containerHeight && !(chessPieceCpu.hasOwnProperty(chessPieceX + "-" + moveBottom) || chessPiecePlayer.hasOwnProperty(chessPieceX + "-" + moveBottom))) {
                            return spriteSuggest; //limit bottom
                        }
                        if (nextY > containerHeight) {
                            delete listChessChange[tmp];
                            delete spriteSuggest[tmp];
                            return spriteSuggest; //chess next player;
                        }
                        if (playerTurn) {
                            
                            if (chessPieceCpu.hasOwnProperty(chessPieceX + "-" + moveBottom)) {
                                // Kiểm tra xem quân tiếp theo có phải là của player không. Nếu phải thì cờ cpu đang được bao bọc trong player delete mảng and return
                                if (chessPiecePlayer.hasOwnProperty(chessPieceX + "-" + nextY)) {
                                    delete listChessChange[tmp];
                                    delete spriteSuggest[tmp];
                                    return spriteSuggest; //chess next cpu;
                                }
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([chessPieceX + "-" + moveBottom]);
                                } else {
                                    listChessChange[tmp] = [chessPieceX + "-" + moveBottom];
                                }
                                // exitst
                                chessPieceY = moveBottom;
                                spriteSuggest[tmp] = ([{"x" : chessPieceX, "y" : nextY}]);
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        } else {
                            
                            if (chessPiecePlayer.hasOwnProperty(chessPieceX + "-" + moveBottom)) {
                                // Kiểm tra xem quân tiếp theo có phải là của cpu không. Nếu phải thì cờ player đang được bao bọc trong cpu delete mảng and return
                                if (chessPieceCpu.hasOwnProperty(chessPieceX + "-" + nextY)) {
                                    delete listChessChange[tmp];
                                    delete spriteSuggest[tmp];
                                    return spriteSuggest; //chess next cpu;
                                }
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([chessPieceX + "-" + moveBottom]);
                                } else {
                                    listChessChange[tmp] = [chessPieceX + "-" + moveBottom];
                                }
                                // exitst
                                chessPieceY = moveBottom;
                                spriteSuggest[tmp] = ([{"x" : chessPieceX, "y" : nextY}]);
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        }
                        
                    } else if (directions === 1) {
                        moveLeft = chessPieceX - move;
                        moveTop = chessPieceY - move;

                        nextX = moveLeft - move;
                        nextY = moveTop - move;
                        // check limit on the left
                        if ((moveLeft <= 0 || moveTop <= 0)
                            && !(chessPieceCpu.hasOwnProperty(moveLeft + "-" + moveTop) || chessPiecePlayer.hasOwnProperty(moveLeft + "-" + moveTop))
                        ) {
                            return spriteSuggest; //limit left
                        }
                        if (nextY < 0 || nextX < 0) {
                            delete listChessChange[tmp];
                            delete spriteSuggest[tmp];
                            return spriteSuggest; //chess next player;
                        }
                        // check exitst chesse piece cpu or chess piece player
                        if (playerTurn) {
                            
                            if (chessPieceCpu.hasOwnProperty(moveLeft + "-" + moveTop)) {
                                // Kiểm tra xem quân tiếp theo có phải là của player không. Nếu phải thì cờ cpu đang được bao bọc trong player delete mảng and return
                                if (chessPiecePlayer.hasOwnProperty(nextX + "-" + nextY)) {
                                    delete listChessChange[tmp];
                                    delete spriteSuggest[tmp];
                                    return spriteSuggest; //chess next cpu;
                                }
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveLeft + "-" + moveTop]);
                                } else {
                                    listChessChange[tmp] = [moveLeft + "-" + moveTop];
                                }
                                // exitst
                                chessPieceX = moveLeft;
                                chessPieceY = moveTop;
                                spriteSuggest[tmp] = ([{"x" : nextX, "y" : nextY}]);
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        } else {
                            
                            if (chessPiecePlayer.hasOwnProperty(moveLeft + "-" + moveTop)) {
                                // Kiểm tra xem quân tiếp theo có phải là của cpu không. Nếu phải thì cờ player đang được bao bọc trong cpu delete mảng and return
                                if (chessPieceCpu.hasOwnProperty(nextX + "-" + nextY)) {
                                    delete listChessChange[tmp];
                                    delete spriteSuggest[tmp];
                                    return spriteSuggest; //chess next cpu;
                                }
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveLeft + "-" + moveTop]);
                                } else {
                                    listChessChange[tmp] = [moveLeft + "-" + moveTop];
                                }
                                // exitst
                                chessPieceX = moveLeft;
                                chessPieceY = moveTop;
                                spriteSuggest[tmp] = ([{"x" : nextX, "y" : nextY}]);
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        }
                    } else if (directions === 3) {
                        let tmpX = coordinatesXRoot + coordinatesYRoot;
                        moveRight = chessPieceX + move;
                        moveTop = chessPieceY - move;

                        nextX = moveRight + move;
                        nextY = moveTop - move;
                        // check limit on the right
                        if ((moveRight >= containerWidth - (yellowDisplay.width + 2) || moveTop <= 0)
                            && !(chessPieceCpu.hasOwnProperty(moveRight + "-" + moveTop) || chessPiecePlayer.hasOwnProperty(moveRight + "-" + moveTop))
                        ) {
                            return spriteSuggest; //limit right
                        }
                        if (nextX >= containerWidth || nextY < 0) {
                            delete listChessChange[tmp];
                            delete spriteSuggest[tmp];
                            return spriteSuggest; //chess next player;
                        }
                        // check exitst chesse piece cpu or chess piece player
                        if (playerTurn) {
                            
                            if (chessPieceCpu.hasOwnProperty(moveRight + "-" + moveTop)) {
                                // Kiểm tra xem quân tiếp theo có phải là của player không. Nếu phải thì cờ cpu đang được bao bọc trong player delete mảng and return
                                if (chessPiecePlayer.hasOwnProperty(nextX + "-" + nextY)) {
                                    delete listChessChange[tmp];
                                    delete spriteSuggest[tmp];
                                    return spriteSuggest; //chess next cpu;
                                }
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveRight + "-" + moveTop]);
                                } else {
                                    listChessChange[tmp] = [moveRight + "-" + moveTop];
                                }
                                // exitst
                                chessPieceX = moveRight;
                                chessPieceY = moveTop;
                                spriteSuggest[tmp] = ([{"x" : nextX, "y" : nextY}]);
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        } else {
                            
                            if (chessPiecePlayer.hasOwnProperty(moveRight + "-" + moveTop)) {
                                // Kiểm tra xem quân tiếp theo có phải là của cpu không. Nếu phải thì cờ player đang được bao bọc trong cpu delete mảng and return
                                if (chessPieceCpu.hasOwnProperty(nextX + "-" + nextY)) {
                                    delete listChessChange[tmp];
                                    delete spriteSuggest[tmp];
                                    return spriteSuggest; //chess next cpu;
                                }
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveRight + "-" + moveTop]);
                                } else {
                                    listChessChange[tmp] = [moveRight + "-" + moveTop];
                                }
                                // exitst
                                chessPieceX = moveRight;
                                chessPieceY = moveTop;
                                spriteSuggest[tmp] = ([{"x" : nextX, "y" : nextY}]);
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        }
                    } else if (directions === 5) {
                        // let tmpX = coordinatesXRoot + coordinatesYRoot - containerWidth;
                        moveRight = chessPieceX + move;
                        moveBottom = chessPieceY + move;

                        nextX = moveRight + move;
                        nextY = moveBottom + move;
                        // check limit on the right
                        // containerwidth - 23 limit x groupCotainer
                        if ((moveRight >= containerWidth - (yellowDisplay.width + 2) || moveBottom >= containerWidth - (yellowDisplay.width + 2))
                            && !(chessPieceCpu.hasOwnProperty(moveRight + "-" + moveBottom) || chessPiecePlayer.hasOwnProperty(moveRight + "-" + moveBottom))
                        ) {
                            return spriteSuggest; //limit right
                        }
                        if (nextX >= containerWidth || nextY >= containerHeight) {
                            delete listChessChange[tmp];
                            delete spriteSuggest[tmp];
                            return spriteSuggest; //chess next player;
                        }
                        // check exitst chesse piece cpu or chess piece player
                        if (playerTurn) {

                            if (chessPieceCpu.hasOwnProperty(moveRight + "-" + moveBottom)) {
                                // Kiểm tra xem quân tiếp theo có phải là của player không. Nếu phải thì cờ cpu đang được bao bọc trong player delete mảng and return
                                if (chessPiecePlayer.hasOwnProperty(nextX + "-" + nextY)) {
                                    delete listChessChange[tmp];
                                    delete spriteSuggest[tmp];
                                    return spriteSuggest; //chess next player;
                                }
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveRight + "-" + moveBottom]);
                                } else {
                                    listChessChange[tmp] = [moveRight + "-" + moveBottom];
                                }
                                // exitst
                                chessPieceX = moveRight;
                                chessPieceY = moveBottom;
                                spriteSuggest[tmp] = ([{"x" : nextX, "y" : nextY}]);
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        } else {
                            
                            if (chessPiecePlayer.hasOwnProperty(moveRight + "-" + moveBottom)) {
                                // Kiểm tra xem quân tiếp theo có phải là của cpu không. Nếu phải thì cờ player đang được bao bọc trong cpu delete mảng and return
                                if (chessPieceCpu.hasOwnProperty(nextX + "-" + nextY)) {
                                    delete listChessChange[tmp];
                                    delete spriteSuggest[tmp];
                                    return spriteSuggest; //chess next player;
                                }
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveRight + "-" + moveBottom]);
                                } else {
                                    listChessChange[tmp] = [moveRight + "-" + moveBottom];
                                }
                                // exitst
                                chessPieceX = moveRight;
                                chessPieceY = moveBottom;
                                spriteSuggest[tmp] = ([{"x" : nextX, "y" : nextY}]);
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        }
                    } else {
                        // directions = 7
                        // let tmpX = coordinatesXRoot + coordinatesYRoot;
                        moveLeft = chessPieceX - move;
                        moveBottom = chessPieceY + move;

                        nextX = moveLeft - move;
                        nextY = moveBottom + move;
                        // check limit on the right
                        if ((moveBottom <= containerWidth - (yellowDisplay.width + 2) || moveLeft <= 0)
                            && !(chessPieceCpu.hasOwnProperty(moveLeft + "-" + moveBottom) || chessPiecePlayer.hasOwnProperty(moveLeft + "-" + moveBottom))
                        ) {
                            return spriteSuggest; //limit right
                        }
                        if (nextX < 0 || nextY >= containerHeight) {
                            delete listChessChange[tmp];
                            delete spriteSuggest[tmp];
                            return spriteSuggest; //chess next player;
                        }
                        // check exitst chesse piece cpu or chess piece player
                        if (playerTurn) {
                            
                            if (chessPieceCpu.hasOwnProperty(moveLeft + "-" + moveBottom)) {
                                // Kiểm tra xem quân tiếp theo có phải là của player không. Nếu phải thì cờ cpu đang được bao bọc trong player delete mảng and return
                                if (chessPiecePlayer.hasOwnProperty(nextX + "-" + nextY)) {
                                    delete listChessChange[tmp];
                                    delete spriteSuggest[tmp];
                                    return spriteSuggest; //chess next player;
                                }
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveLeft + "-" + moveBottom]);
                                } else {
                                    listChessChange[tmp] = [moveLeft + "-" + moveBottom];
                                }
                                // exitst
                                chessPieceX = moveLeft;
                                chessPieceY = moveBottom;
                                spriteSuggest[tmp] = ([{"x" : nextX, "y" : nextY}]);
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        } else {
                            if (chessPiecePlayer.hasOwnProperty(moveLeft + "-" + moveBottom)) {
                                // Kiểm tra xem quân tiếp theo có phải là của cpu không. Nếu phải thì cờ player đang được bao bọc trong cpu delete mảng and return
                                if (chessPieceCpu.hasOwnProperty(nextX + "-" + nextY)) {
                                    delete listChessChange[tmp];
                                    delete spriteSuggest[tmp];
                                    return spriteSuggest; //chess next cpu;
                                }
                                //add list chess click change
                                listArr = listChessChange[tmp];
                                if (listArr !== undefined) {
                                    listChessChange[tmp] = listArr.concat([moveLeft + "-" + moveBottom]);
                                } else {
                                    listChessChange[tmp] = [moveLeft + "-" + moveBottom];
                                }
                                // exitst
                                chessPieceX = moveLeft;
                                chessPieceY = moveBottom;
                                spriteSuggest[tmp] = ([{"x" : nextX, "y" : nextY}]);
                                checkMove(chessPieceX, chessPieceY, directions, spriteSuggest, coordinatesXRoot, coordinatesYRoot);
                            }
                        }
                    }

                    return spriteSuggest;
                }
        </script>
    </body>
</html>